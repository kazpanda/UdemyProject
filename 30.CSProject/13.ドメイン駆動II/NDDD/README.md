# ドメイン駆動
* ドメイン駆動学習用

## 1.プロジェクト構成
* プロジェクトを分ける理由は、可読性を高める、保守性高める
* 新しいテクノロジーが出てきたとき、プロジェクトを変更するの載せ替えられる

  ### 1.1.Domain
  * ビジネスロジック
  * どこも参照しない。見られるだけ
  * C#プレーンなコードを書く

  ### 1.2.Infrastructure
  * アプリケーションの外側と接触するもの
  * Domainを参照する
  * SQL、ファイルアクセス、通信 外部のテクノロジーが変化したらここだけ変更する
  * 外部の事情で変わるので、変更が生じた場合はここだけを変更する
  * ユニットテストを書きやすくする
  * Applicationは必要か？冗長化になる、ビジネスロジック、ViewModelどちらか迷う
  * Application層はWinFormとInfrastructure層の間くらい
  * App層をいれると処理が冗長化しやすい

  ### 1.3.WinForm
  * 画面
  * DomainとInfrastructureを参照
  * 時代とともに見た目は変化する ここだけ変更する
  * プロジェクトを分ける理由は新しいテクノロジがでてきたときに変更しやすい

  ### 1.4.NDDDTest.Tests
  * ユニットテスト
  * 全て参照


## 2.Domainのフォルダー構成
* Domainのフォルダー構成について

  ### 2.1.Entities
  * モデル＋ビジネスロジック
  * 一意なデータの塊、データベース１行、行の中で完結するロジックの置き場所
  * データモデルのイメージ

  ### 2.2.ValueObjects
  * データ＋ビジネスロジック
  * 値として扱うクラス
  * 数字の「3」等をそのまま扱うとビジネスロジックが散らばるためValueObjectの「3」として扱う
  * データベースの列のValueObject化が有効

  ### 2.3.Repositories
  * インターフェース＋（ビジネスロジック）
  * アプリケーションの外部と接触する部分は全てインターフェイスを作る
  * テストの容易性

  ### 2.4.Exceptions
  * エラー処理は基本は例外処理を行う
  * Exceptionを継承した例外クラスの集まり
  * 基本的に異常は例外で表す
  * 戻り値をboolにして判断しない
  * 呼び元にifを書かせない
  * 値が戻ったら正常、エラー時はcatchで
  * ただしループで全て例外が発生するような箇所は考慮する

  ### 2.5.Helpers
  * 共通関数的なもの
  * staticでどこにあってもいいもの
  * 害がないもの。桁を揃えるとか
  * マイクロソフトが作ってくれたら不要だったよ！的なもの
  * ビジネスロジックが無い[Logicsとの比較]
  　
  ### 2.6.StaticValues
  * 共通変数的なもの
  * 値をキャッシュとして保存する場合

  ### 2.7.Logics
  * Staticでビジネスロジックを含むもの
  * 分析、診断ロジックなど


## 3.Infrastructureのフォルダー構成
* 外部機器と接触するもの
* クラスはinternalで作成しFactoryだけpublicにする
* インスタンスの生成はFactory以外ではできなくする

  ### 3.1.なぜ外部との接触を集めるのか？

  * 外部の影響を局所化する
  * テスト容易性

  ### 3.2.フォルダー構成
  * テクノロジーごとにフォルダーを分ける
  * 外部にアクセス部分のロジックのみを記述
  * Domain層のRepositoryにあるインターフェースを使う
  * SQLServer
  * Csv
  * 外部機器
  * Fake ダミーデータ
  * Factoryパターン 本番コードとFakeパターンを切り替える


## 4.WinFormのフォルダー構成
* WinFormのフォルダー構成

  ### 4.1.ユーザーインターフェース層
  * 時代の変化とともに変化する部分

  ### 4.2.ビジネスロジックとの分離
  * MVVMパターンの適応
  * ドメイン層やインフラストラクチャー層の機能を選ぶ

  ### 4.3.フォルダー構成
  * ViewModels
  * Views
  * BackgroundWorkers

  ### 4.4.タイマーイベントはどこに入れる？
  * イベントはユーザーインターフェイス層でのみ発生させる
  * 理由：保守性を上げるため。修正時に追いやすいコード
  * 勝手に動いているものがあると大変


## 5.Testsのフォルダー構成
* テストコードのみを書く
* メソッド名は日本語でOK

  ### 5.1.フォルダー構成
  * 本番コードの構成
  * Domain.ValueObjects.MeasureValueクラスなら
    Domain.ValueObjects.MeasureValueTestsのテストクラスを作る
  
  ### 5.2.ViewModelへのテスト
  * 基本的にViewModelに対してテストを書けばOK

  ### 5.3.Infrastructureのテスト
  * 不要
  * Moqにて代用

  ### 5.4.画面のテスト
  * 不要
  * ViewModelに対してテストを書けばOK
  * 実際の画面は目で見てテストする

  ### 5.5.お勧めの支援ツール
  * ChainingAssertion
  * Moq
  * AxCover


## 6.Sharedクラスを作成する
* Staticな変数を一元化する
* Domain直下にSharedクラスを作成し状態を保存する
* Fake切り替えや状態を保存する


## 7.Factoriesクラスを作成する
* インスタンスを生成する箇所を一元化
* FakeかSQLか切り替えがわかりやすくなる
* DebugビルドとReleseビルドでインスタンス生成の処理を切り替える
* Factory以外でインスタンス生成できなくする クラスをinternalにする
* Factoryの呼び出しはViewModelで行う
* 画面から呼び出したときは本番を呼び出しテストから呼び出したときはMockが呼ばれるなど


## 8.設定の外部ファイル化
* 参照からSystem.Configurationを追加
* App.configの変更
* NDDD.configの追加


## 9.BaseFormを作る
* Form共通の基底Form
* 例外処理時のメッセージボックスも書ける
* ステータスバーとか


## 10.ValueObjectについて
* ValueObjectは、値＋ロジック
* 何をValueObjectにするか？DBのフィールド
* モデルだと値型(intなど)なので振る舞いが実装できない
* 振る舞いを実装すると、ロジックがViewにあったりViewModelにあったり散らばる
* 値にビジネスロジックがあればValueObject化（クラス化）する
* 注意点
* 完全コンストラクタ型で作成する（すべての引数）
* Newした時に値をセットして、以降は変更できない（getのみ実装する）
* 問題点
* ValueObjectはクラスなので、値が同じでもイコールにはならない（参照型なので）
* 抽象クラスを用意して、イコールイコール問題を対処する


## 11.オブジェクト指向の自動化
* オブジェクト指向の実装をしたい
* 課題：
* 一人ひとりの認識が違い、ばらばらになる
* デザパタにしろ、アーキテクチャーにしろ、あいまい
* そこでDDDを実践する
* モデルを基準に考えて組み立てていくと７、８割オブジェクト指向になる

  ### 11.1.外部からのデータ（DBの列）をすべてValueObjectにする
  * ビジネスロジックが無ければ不要かもしれない  

  ### 11.2.DBの値を運ぶ形でEntityにする（モデル）
  * Select分相当のEntityにValueObjectに乗せる  
  * ValueObjectの組み合わせ
  * 複合的ValueObjectなビジネスロジックはEntityにて書く  

  ### 11.3.外部接触部はリポジトリーにする
  * リポジトリー経由で値をとってくる
  * ここまでで、8割のクラス分けができる


## 12.Repositoryの具象クラス
* Infrastructure層はシンプルに値だけをとる（SQLでごちゃごちゃ書かない）
* ごちゃごちゃ処理はC#で書いたほうが良い
* DBから取ってきた値にビジネスロジックを書く場合、ViewModelに書くとロジックが散らばる
* SQLで取ってきて加工して渡すだけなら、Repositoryの具族クラスに書くことも検討
* ただし複雑なロジックは置かない


## 13.例外処理
* バケツリレーはしない。C#は例外でエラーを検知
* バケツリレーはif分が必要で、漏れたりバグが混入しやすい
* 正常な値が返ってきたら正常、エラーだったら例外
* 呼び出しもとでtry、catchする


## 14.インナーエクセプション
* throwだけでは、例外が発生したExceptionが呼び出しもとに渡せない
* メッセージとExceptionを呼び出しもとに渡すことが必要
* 例外クラスに引数を追加


## 15.例外の欠点
* 処理コストがかかる
* ループ処理の中で100回のループで、100回の例外が発生する可能性があるような場合は、例外はさせない


## 16.メッセージ区分とエラー処理の共通化
* カスタムExceptionを作った場合、エラー区分を設定することにより警告メッセージの共通化が図れる
* 抽象基底クラスを作り、エラー区分を作成する
* 基底クラスに抽象メソッドを作ることにより、エラー区分の実装を強制化ができる


## 17.ログの出力
* 一般的にlog4net
 

## 18.タイマー処理はどこに置くか？
* Event関係はUI層に集めておいたほうが追いやすい
* タイマーはきっかけとなるUI層に置いたほうが良い


## 19.StaticValues(キャッシュ)
* DBから取ってきた値などを保存しておく変数
* あっちこっちに置くと見通しが悪いので一か所にまとめておく
* 変数はSharedに置いて、リストはStaticValuesに置いてLockをかけてどこからでもアクセスできるように

## 20.Logics
* 独立したロジックはLogicに置く（分析とか）
* Staticな関数
* ビジネスロジックは基本的にはValueObjectもしくはEntityに置く


## 21.Helpers
* 共通関数的な関数を置く


## 22.Module
* どこにも収まらないロジックを入れる


## 23.トランザクションはどこで掛けるか
* ViewModelで掛けるのが融通がきく
* Infrastructureでトランザクションを掛けると、融通が利かない
* System.Transactionsを使用しusingで囲む



